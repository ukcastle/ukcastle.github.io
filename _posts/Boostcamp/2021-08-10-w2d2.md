---
layout: post
title: Deep Learning Basics - Optimization
category: BC
tag: [Deep Learning] 
use_math: true
---

## Optimization

최적화엔 여러가지 중요한 컨셉들이 있다. 한 가지씩 알아보자  

#### Generalization

- 일반화
- 학습된 모델이 테스트 데이터에 얼마나 잘 작동하는지.  
- 테스트 데이터를 넘어, 실 생활에 적용할때도 얼마나 잘 적용되는지에 대한 척도이다.  

#### Underfitting vs Overfitting

- 과소적합, 과대적합
- 둘 중 중간의 적절한 함수를 찾는것이 목표이다.  
- 하지만 매우 추상적인 개념이다. 과대적합 된 그래프가 정답일 수도 있다.  

#### Cross-Validation 

- 교차검증
- test셋은 그대로 두고, train 셋을 분할하여 모델을 훈련하는 방법이다.  
- 보통 1개로 검증하고 나머지를 학습시키는 식으로 시행한다.  
- 최종 모델을 만들 때 사용하는게 아닌, 최적의 하이퍼파라미터를 조정할 때 사용한다.

#### Bias and Variance  

- 정확도, 그리고 분산
- 사격에서의 탄착군 형성을 생각해보자.
- 정 가운데에 모두 몰려있으면 좋은 결과라고 보지만, 정답이 아니더라도 한 곳에 몰려있으면 그것도 괜찮은 결과라고 본다.

#### Bootstrapping  

- 부트스트래핑
- 원래의 데이터를 랜덤으로 샘플링하여, 훈련 데이터를 늘리는 방식이다.  
- 일련의 테스트를 할 때, 데이터의 분포가 고르지 않는 경우 이를 이용한다.  

#### Bagging vs Boosting

- **B**ootstrapping **agg**regat**ing**
  - 여러개의 모델을 만들고 평균을 내는 방식
  - 앙상블
- Boostring
  - 특정한 훈련 샘플에 집중하여 훈련시키는 방식
  - 1000개의 데이터가 있다고 할 때, 특정한 100개의 데이터에 대한 모델을 만든다.
  - 그 다음, 다른 100개에 대해서 해당 모델로 검증을 한 뒤, 정확도를 개선한다.  
  - 이런 방법을 **순차적**으로 반복하는 것을 부스팅이라고 한다.  

## Gradient Descent Method

경사하강법에서 배치를 정하는 데에, 3가지 방법이 있다.  
1. Stochastic Gradient Descent(SGD)  
   한 개의 샘플에 대하여 미분값를 측정한다.  
2. Mini-batch Gradient Descent  
    데이타의 특정한 크기의 subset을 정하여 미분값을 측정한다.   
3. Batch Gradient Descent  
    모든 데이터를 가지고 측정한다.

- 배치사이즈에 대한 논의점  
  - Batch Gradient Descent를 이용할 때, **Sharp Minimizers**의 값이 나왔다.  
  - Small-Batch를 이용할 땐 **Flat Minimizers**의 값이 나왔다.  
  - 정리하자면, Sharp한 최소값은, Generalization의 측면에서 볼 때 효율이 많이 떨어진다. 보통의 상황에선 Flat한 최소값이 효율이 좋게 나온다.  


#### Gradient Descent Methods

정확한 식에 대해선 적지 않겠다. 간단한 정리만..  

1. Stochastic Gradient Descent  
   기본적으로 다음 예측값에 현재 미분값과 가중치를 곱해 빼는 연산이다.  
   문제점이 있다면 올바른 가중치를 정하기가 힘들다는 점이다.  

2. Momentum  
   Momentum이라는 새로운 변수를 추가한다.  
   관성이라고 생각하면 편한데, 경사하강법을 하면서 같은 방향으로 내려가는 경우 가속력을 붙여 내려간다.  
   하지만 관성으로 인해 최솟값에 수렴하기까지 오래 걸린다는 단점이 있다.(U자형 관에 공을 굴린다고 생각해보자. 좌우로 지속적으로 움직인다)  

3. Nesterov Accelerated Gradient  
   Momentum 방식을 사용할 때 단점은, Local Minima로 잘 수렴하지 못한다는 점이다.  
   핵심은 **다음 스텝을 미리 계산한 뒤** 이동하는 것이다.  
   따라서 제동을 걸 위치에 제동을 걸어서, 수렴하기 쉽다는 장점이 있다.  

4. Adagrad
    많이 변한 변수는 정답에 가까이 있을 확률이 높고, 적게 변한 변수는 정답에서 멀리 있을 확률이 높다는 개념을 적용하여 각 parameter별로 변화량을 측정해 변화량을 조절하는 방법이다.  
    연산이 길어질수록 학습률이 너무 저조해진다는 단점이 있다.  

5. Adadelta  
    많이 활용되지 않는 방법이다. Adagrad를 기본 원리로 채택하지만 누적된 값의 변화량이 아닌, 일정한 크기의 window만큼의 변화량의 지수평균만 사용하는 방법이다. 학습량을 지정해주지 않아도 된다는 장점이 있다.  

6. RMSprop  
   이 또한 Adagrad를 기본 원리로 채택한 방법이며 많이 사용됐던 방식이다.  
   변화량을 합이 아닌 지수평균으로 바꾸어서 대채한 방법이다.  

7. Adam  
   오늘날 가장 많이 사용되는 방식이다.  
   RMSprop + Momentum 으로 생각하면 편하다.  
   Momentum 방식과 유사하게 지금까지 계산해온 기울기의 지수평균을 저장하며 RMSprop과 유사하게 기울기의 제곱값의 지수평균을 저장한다.  
   $B_1, B_2$라는 새로운 파라미터가 생겼는데, 각각 모멘텀과 EMA를 얼마나 유지할 지에 대한 가중치이다.  

## Regularization

Generalization이 잘 돌아가게 하기 위해 학습을 방해하는 방식이다.(엄밀히 말하자면 테스트 데이터에 대한 과대적합을 막기 위한 방법이다.)  
무엇이 정답이다라는 것은 없으며, 하나씩 넣어보며 잘 되나 안되나 해보는 것이 좋다.  

1. Early Stopping  
    테스트셋에서 가장 잘 적합하는 부분에서 모델의 훈련을 멈추는 방식  
2. Parameter Norm Penalty  
    신경망이 만드는 파라미터가 너무 커지지 않게 한다.  
    Funtion Space를 부드럽게 만드는 방식
3. Data Augmentation  
    데이터의 양을 증가시키는 방법이다.  
    이미지 데이터라고 하면, Label이 변하지 않는 정도 내에서 모델을 뒤집거나, 흔들거나, 반전을 시키는 등의 행위이다.  
4. Noise Robustness  
    랜덤한 노이즈를 데이터에 넣는다. 왜 더 잘되는거지?  
5. Label Smoothing  
    모델이 타겟을 정확하게 예측하지 않게 해주는 방법이다.  
    예를들어, 개와 고양이의 사진이 있을때 개와 고양이의 사진을 적절히 섞는다(흐리기를 조정하여 적절하게 섞는 Mixup과, 아예 이미지를 잘라 붙이는 CutMix 등)  
    그 다음 개50%, 고양이50% 정도의 값을 출력해내게 하여 모델의 과대적합을 막는 방식이다.  
6. Dropout  
    랜덤하게 뉴런들을 zero로 만들어버리는 방법으로, 각각의 뉴런들이 더욱 강해지는(Robust) 결과를 가져다준다.  
7. Batch Normalization  
    논란이 많지만 자주 사용하는 방법이다.  
    신경망 안에 평균과 분산을 조정하는 과정을 추가하여, 즉 레이어마다 정규화하는 레이어를 두어 변형된 분포가 나오지 않도록 조절하는 방식이다.  
    이 부분에 대해서는 더욱 공부가 필요하다.  

## 피어세션 정리

[추후 참고할만한 1기 캠퍼님 블로그](https://philgineer.github.io)
[k-validation](https://nonmeyet.tistory.com/entry/KFold-Cross-Validation교차검증-정의-및-설명)  
[Attention Is All You Need](http://nlp.seas.harvard.edu/2018/04/03/attention.html)  
[RMS Prop, Adam](https://light-tree.tistory.com/141)  
[RAdam](https://zzaebok.github.io/deep_learning/RAdam/)  
[MDN 한글번역](https://kangbk0120.github.io/articles/2018-05/MDN)  
[k-validation k값 정하는 척도](https://machinelearningmastery.com/difference-between-a-parameter-and-a-hyperparameter/)  
[부스팅과 앙상블](https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-11-%EC%95%99%EC%[…]A%B9%85Bagging%EA%B3%BC-%EB%B6%80%EC%8A%A4%ED%8C%85Boosting)   

## 회고

가볍게만 훑어봤지만, 추후 모델의 성능을 위해서는 꼭 다시 찾아봐야 할 내용이다. 각각을 한 파트로 공부해서 포스팅해야겠다는 생각이 들었다.  